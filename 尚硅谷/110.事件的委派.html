<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    window.onload = () => {
      //點擊按鈕以後添加超連結
      let btn01 = document.getElementById("btn01");
      btn01.onclick=function(){
        //創建一個li標籤
        let li = document.createElement("li")
        li.innerHTML="<a href=javascript:; class=link>新建的超連結</a>";

        //抓取ul
        let ul = document.getElementById("ul")
        //將li標籤添加到ul中
        ul.appendChild(li)
      }


      //為每一個超連結綁定單擊響應函數
      //這裡我們為每一個超連結都綁定一個單擊響應函數，這種操作比較麻煩
      //而且這些操作只能為已有的超連結設置事件，而新添加的超連結必須重新綁定
      let allA = document.getElementsByTagName("a");

      //遍歷，不能為新添加的超連結做單擊響應效果
      // for (let i = 0; i < allA.length; i++) {
      //   allA[i].onclick = function(){
      //     alert("a")
      //   }

      //我們希望，只綁定一次事件，即可應用在多個元素上，即使元素是後添加的
      //我們可以將其嘗試將其綁定給元素的共同祖先元素

      //事件的委派
      //-將我們事件統一綁定給元素的共同祖先元素，這樣當後代元素上的事件觸發時，
      //會一直冒泡到祖先元素，從而通過祖先元素的響應函數來處理事件

      //-事件的委派是利用了冒泡，通過委派可以減少事件綁定的次數，提高程序的性能

      //為ul綁定一個單擊響應函數
      ul.onclick=(event)=>{
        //target:獲取觸發特定事件的元素
        //-event.target 表示觸發事件的物件
        //如果觸發事件的物件是我們期望的元素，則執行否則不執行
        if(event.target.className=="link"){
          alert("a");
        }

        
      }
      }
    
  </script>
</head>

<body>
  <button id="btn01">添加超連結</button>
  <ul id="ul" style="background-color: yellow;">
    <li>
      <p>我是p元素</p>
    </li>
    <li><a href="javascript:;" class="link">超連結1</a></li>
    <li><a href="javascript:;" class="link">超連結2</a></li>
    <li><a href="javascript:;" class="link">超連結3</a></li>
  </ul>
</body>

</html>